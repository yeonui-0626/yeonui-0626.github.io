---
layout: post
title: "[BOJ] 백준 17135 번 캐슬디펜스"
subtitle:
categories: Algorithm
tags: [boj, 부분집합, 구현 ]
---

## 백준 17135 번 캐슬디펜스

[문제보기](https://www.acmicpc.net/problem/17135)

### 1. 문제 풀이

- N*M의 배열이 입력으로 들어온다.
- 적이 있는 곳은 1로 표시되며, 한칸에 적은 1명 있을 수 있다.
- 궁수는 N 에 위치한다. (배열의 인덱스는  ~ N 이므로)
  - 궁수는 3명 배치할 수 있다.
- 궁수는 공격 시, 거리가 D 이내인 적 중, 가장 가까운적 1명을 공격할 수 있다.
  - **가까운 적이 여러명이라면 가장 왼쪽의 적을 먼저 공격한다.**
- 궁수의 공격이 종료되면 적은 아래로 1칸씩 이동한다.
  - N번째 줄이 있는 적이 이동하면 적은 그냥 사라지는 것이다. 
- 궁수의 공격으로 인해 죽는 적의 최대값을 구한다.

1. 먼저 궁수를 3명 배치한다.
   1. 궁수는 N 줄에 배치할 수 있다.
   2. 0~M+1의 수중 3개를 선택한다. 
2. 궁수 3명을 선택했다면, 공격 ! ->`shoot()`
   1. 죽일 수 있는 가까운 적부터 확인.
      - 거리가 1인 적 부터 D인 적까지 확인
   2. 왼쪽의 적을 먼저 죽어야하므로 col 0 부터 확인 
   3. 거리가 d인 적을 확인하고 있다면 N-1번째 줄부터 궁수에서 d만큼 떨어진 row만 확인    
    ==> `shoot()`의 3중 for문
   - 궁수마다 죽일 적을 한명 선택했다면 kill 배열에 표시하고 모든 for문을 빠져나온다
3. 궁수의 공격이 끝났다면 적을 아래로 이동 시킨다 -> `move()`
4. 2번 3번 과정을 모든 적이 없어 질때까지 반복한다.
   1. `remain()`을 통해 남을 적의 수를 세고 whilea문을 통해 0이 될 때까지 반복

### 2. 시행착오
- 내가 풀어본 골4 문제 중에 젤 까다로웠던 것 같다. 정답률이 30%대 .. 
- 궁수가 죽일 적을 선택하는게 제일 까다로웠는데 항상 4방, 8방 탐색으로 선택 하다가 거리로 선택하는 것을 구현하는 게 어려웠다.


### 3. 코드

<script src="https://gist.github.com/yeonui-0626/e42ce2b70fc164e5ca293fa06b510cb3.js"></script>

