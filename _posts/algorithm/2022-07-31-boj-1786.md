---
layout: post
title: "[BOJ] 1786 번 찾기(KMP를 알아보자)"
subtitle: 문자열 비교 알고리즘
categories: Algorithm
tags: [boj, KMP]
---

# 백준 1786 번 찾기

[문제보기](https://www.acmicpc.net/problem/1786)


## 1. 문제 풀이

## KMP 알고리즘

- KMP 알고리즘이란, 전체 문자열에서 특정 문자열을 빠르게 찾는 알고리즘이다.
- 아이디어가 아주 획기적인 알고리즘이다.


 
**보통의 아이디어(Navie 알고리즘)**
- 탐색할 문자열을 text, 특정 문자열을 pattern이라고 해보자.
- 보통 text 중, 특정 문자열 pattern을 찾는다고 생각하면 text에서 시작인덱스를 옮겨가며 모든 연속된 부분 문자열을 보고 연속된 부분 문자열과 찾고자하는 pattern 문자열을 비교하는 방식을 생각한다.
- 이를 코드로 옮겨보면 이중 for 문을 사용하게 되고, 시간 복잡도는 `O(N^M)` 이 된다.     
`(N: text 길이, M : pattern 길이)`
- 간단한 방법이지만 하나하나 비교하는건 비효율적일수 밖에 없다.

**시간을 줄일려면 ?**
- 문자열 비교 중 문자열이 다를 때 시작 인덱스를 이동해 처음부터 다시 비교를 시작한다.
- 문자열 비교 중, 일치하는 부분이 있었는데 또 다시 비교하는 것은 낭비이다.
- 일치하는 문자열이 있었다는 것을 이용해 탐색 시작위치를 건널 수 있다면 시간을 줄일 수 있을 것이다. 
  
**접미사와 접두사**
- KMP 알고리즘을 설명한 다른 블로그를 보면 접미사와 접두사를 소개한다. 
- 개념에 대한 이해는 다른 블로그를 참고하고 이것을 이용해 어떤 데이터를 만들어내는지 바로 확인해보자.
- `pi[i]` 는 pattern 문자열에서 i 인덱스까지 문자열 중, 접미사와 접두사가 일치하는 최대 길이에 대한 정보가 담겨있다.
  ![Untitled](/assets/images/posts/algo/2022-08-01-1.png)

**KMP 는 문자열을 *빠르게* 찾는 알고리즘이다.**

- 일치하는 길이에 대한 정보가 나와있기 때문에 길이 만큼 이동한 인덱스로 바로 이동하게되면 중복된 검사를 줄일 수 있다.
- 예를 들어 abacaab 까지 확인을 한 뒤, 이후 text 에서 다른 문자열이 나왔을 때, pi에 저장된 2 인덱스(겹치는 접미사의 끝)로 이동해 다시 비교한다.


- 앞서 생성한 pi 테이블을 이용하면 text를 한번만 전체 탐색하면 문자열이 있는지를 확인할 수 있다.
- 아래의 예제에서 abab 까지 봤을 때 일치하지 않는다면, pattern을 다시 처음부터 비교하는게 아닌, pi[i-1]의 인덱스부터 다시 비교 ! 
  ![Untitled](/assets/images/posts/algo/22-08-01-2.jpg)
- text를 한번만 탐색하면 되므로 시간복잡도는 `O(N)`


## 2.시행착오

- 알고리즘을 이해하는데 오래걸렸다.
- 접두사와 접미사를 활용하는 이유를 정확하게 파악하는 것이 중요하다.
- [나동빈님의 강의](https://www.youtube.com/watch?v=yWWbLrV4PZ8)와 [이 블로그](https://bowbowbow.tistory.com/6)가 많은 도움이 되었다.



## 3. 코드

<script src="https://gist.github.com/yeonui-0626/5749eeadf3108b644e785aadc958f2b1.js"></script>