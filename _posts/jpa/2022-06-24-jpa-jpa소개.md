---
layout: post
title: "[Spring] JPA ,  "
subtitle:
categories: JPA
tags: [Spring, JPA]
---

### JPA를 실무에 적용하기 어려운 이유

- 객체와 테이블을 잘 설계하고 매핑하는 것이 중요하다.
- 대규모 시스템을 다루는 실무에서는 여러 테이블이 얽혀있기 때문에 객체 와 테이블을 정확하게 매핑하는 것은 어렵다.

### 목표

> 객체와 테이블을 제대로 설계하고 매핑하는 방법알기  
> JPA의 내부 동작 방식 제대로 이해하기
> JPA 가 어떤 SQL을 만들어 내는지 이해하기
> JPA 가 언제 SQL을 실행하는지 이해하기

1. SQL 의존적인 개발의 문제
2. JAVA의 객체 지향 프로그래밍과 데이터베이스의 관계형 프로그래밍은 패러다임이 다르다.
3. 그래서 객체를 데이터베이스를 저장하기 위해서는 SQL을 통한 매핑 작업이 필요하다.
4. 결국 개발자가 SQL 매핑 작업을 반복적으로 해야한다.
5. 객체와 관계형 데이터베이스의 차이
   1. 상속
      1. 객체는 있지만 관계형 데이터베이스는 없다.
      2. 객체의 상속과 유사한 것은 Table의 슈퍼 타입, 서브타입이다.
   2. 연관관계
      1.
   3. 데이터 타입
   4. 데이터 식별 방법

# JPA?

- Java Persistence API
- 자바 진영의 ORM 기술 표준

## ORM ?

- Object-Relcational Mappling(객체-관게 매핑)
- 객체는 객체대로 설계하고 관계형 데이터베이스는 관계형 데이터베이스댈 설계한다.
- 이 둘을 ORM 프레임워크가 중간에서 매핑한다.
- 대중적인 언어에는 대부분 ORM 기술이 존재한다.
  - Django 도 있음
- JPA는 **애플리케이션과 JDBC 사이에서 동작**한다.

### JPA를 왜 사용해야하 하는가?

1. 생산성
   CRUD를 코드 한줄로 할 수 있다.

```java
// 저장
jpa.persist(member)
//조회
Member membe = jpa.find(memeberId)
//수정
members.setName("이름");
// 삭제
jap.remove(member);
```

2. 유지보수

- 기존에는 데이터 베이스에 수정사항이 생기면 관련된 모든 SQL을 수정해야했다.
- JPA를 사용한다면 필드만 추가하면 된다.

3. 패러다임의 불일치 해결

- JPA와 상속
  - 서브 타입, 슈퍼 타입 테이블에 대해 알아서 두개의 쿼리를 생성해 수행한다.
- JPA 와 연관관계, 객체 그래프 탐색
- 엔티티를 신뢰할 수 있다. 계층 사이의 분리가 가능해짐.
- 테이블에서 가져온 엔티디 간 비교를 할 수 있다.
- 1차 캐시와 동일성 보장

  - 같은 트램잭션 안에서는 같은 엔티티를 반환한다. 약간의 조회 성능을 향상한다.

  ```java
  String memberId = "100";
  Member m1 = jpa.find(Memeber.class,memberId); // SQL
  Member m2 = jpa.find(Member.class,memberId) // 캐시
  // m1 == m2 : true
  ```

  - DB Isolation Level이 Read Commit 이어도 애플리케이션에서 Repeatable Read 보장한다.

- 트랜잭션을 지원하는 쓰기 지연
  - 트랜잭션을 커밋할 때까지 INSERT SQL을 모았다가 처리한다.
- 지연 로딩과 즉시 로딩을 옵션으로 설정할 수 있다.
  - 지연 로딩 : 객체가 실제 사용될 때 로딩
  - 즉시 로딩 : JOIN SQL로 한번에 연관된 객체까지 미리 조회한다.
