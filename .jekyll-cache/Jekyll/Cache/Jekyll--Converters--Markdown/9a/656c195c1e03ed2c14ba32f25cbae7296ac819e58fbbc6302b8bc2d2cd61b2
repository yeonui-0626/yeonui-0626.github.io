I"'<h2 id="chapter3-프로세스">Chapter3. 프로세스</h2>

<h2 id="context-프로세스의-문맥">Context 프로세스의 문맥</h2>

<h3 id="프로세스의-문맥context"><strong>프로세스의 문맥(context)</strong></h3>

<p>⇒ 프로세스가 어디까지 수행을 했는가</p>

<ul>
  <li>CPU 수행 상태를 나타내는 하드웨어 문맥
    <ul>
      <li>program counter</li>
      <li>각종 register</li>
    </ul>
  </li>
  <li>프로세스의 주소 공간
    <ul>
      <li>code, data, stack</li>
    </ul>
  </li>
  <li>프로세스 관련 커널 자료 구조
    <ul>
      <li>PCB(Process Control Block)</li>
      <li>Kernel stack</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/images/posts/os/03-17-3-a.png" alt="프로세스1" /></p>

<p><span style="color:#ff5100">운영체제의 커널 주소공간에 각 프로세스의 PCB를 저장하고 있음&lt;/script&gt;
<span style="color:#ff5100">항상 프로세스의 문맥을 파악하고 있다가, CPU가 다시 그 프로세스를 점유했을 때, 그 시점부터 실행&lt;/script&gt;</span></span></p>

<h3 id="프로세스의-상태">프로세스의 상태</h3>

<p><strong>Running</strong> - CPU를 잡고 instruction을 수행중인 상태</p>

<p><strong>Ready</strong> - CPU를 기다리는 상태(필요한 부분은 메모리에 올라가 있음)</p>

<p><strong>Blocked</strong>( wati, sleep)</p>

<ul>
  <li>CPU를 주어도 당장 instruction을 수행 할 수 없는 상태</li>
  <li>Process 자신이 요청한 event 가 즉시 만족되지 않아 이를 기다리는 상태</li>
</ul>

<p>New : 프로세스가 생성중인 상태  <br />
Terminated : 수행이 끝난 상태</p>

<p><img src="/assets/images/posts/os/03-17-3-b.png" alt="프로세스2" /></p>

<div style="text-align:center">
<span style="color:#ff5100">Running -(Event) → Blocked (waiting) - (event complete)→ Ready → Running</span>
</div>
<p><br /></p>

<p><strong>Suspended ( Stopped )</strong>  <br />
외부에서 해당 프로세스를 정지한 상태.  <br />
프로세스를 통째로 <code class="language-plaintext highlighter-rouge">swap out</code> 된다.</p>

<p>⭐ blocked 와의 차이점</p>

<p>blocked : 자신이 요청한 event가 만족되면 Ready  → 자의에 의함</p>

<p>suspended : 외부에서 resume해주어야 Ready       → 타의에 의함</p>

<p>ex) 사람이 프로세스를 정지 시키는 경우</p>

<p>✅ swapping</p>

<p>실행에 따라서 프로세스가 메모리에서 잠깐 디스크 저장공간으로 빠졌다가 다시 메모리가 돌아오는 작업</p>

<ul>
  <li>swap in   : 보조저장장치 → 메모리</li>
  <li>
    <p>swap out : 메모리 → 보조저장장치</p>

    <p>( 프로세스 입장의 상태도)</p>
  </li>
</ul>

<p><img src="/assets/images/posts/os/03-17-3-c.png" alt="프로세스3" /></p>

<ul>
  <li>user mode/monitor mode 둘다 프로세스는 Running 중인 상태</li>
  <li>monitor mode에서 ISR( Interrupt Service Routine ) 실행</li>
</ul>

<h3 id="pcbprocess-control-block">PCB(Process Control Block)</h3>

<ul>
  <li>운영체제가 각 프로세스를 관리하기 위해 프로세스 당 유지하는 정보</li>
  <li>구성 요소(구조체로 유지)
    <ol>
      <li>OS 가 관리하는 정보</li>
      <li>CPU 수행 관련 하드웨어 값</li>
      <li>
        <p>메모리 관련</p>

        <p>Code, Stack, Data 의 위치 정보</p>
      </li>
      <li>파일 관련</li>
    </ol>
  </li>
</ul>

<p><img src="/assets/images/posts/os/03-17-3-d.png" alt="프로세스4" /></p>

<h3 id="문맥교환">문맥교환</h3>

<ul>
  <li>CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정</li>
  <li>CPU가 다른 프로세스에게 넘어갈 때 운영체제는 다음을 수행
    <ul>
      <li>CPU를 내어주는 프로세스의 상태를 그 프로세스의 PCB에 저장</li>
      <li>CPU를 새롭게 얻는 프로세스의 상태를 PCB에서 읽어옴.
  <code class="language-plaintext highlighter-rouge">PCB는 커널에</code></li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><strong>하지만 ! System call 이나 interrupt 발생 시, 반드시 문맥교환이 일어나는 것은 아님.</strong></p>

</blockquote>

<p><img src="/assets/images/posts/os/03-17-3-e.png" alt="프로세스5" /></p>

<p>Timer interrupt 나 I/O 요청 System call 발생 시, 문맥 교환 발생.</p>

<ul>
  <li>Timer interrupt → 할당된 시간이 끝나서 무조건 문맥 교환</li>
  <li>I/O → 시간이 오래걸려서</li>
</ul>

<p>1번의 경우, CPU가 계속 프로세스를 갖고 있음.</p>

<ul>
  <li>1번의 경우에도 CPU 수행정보 등 context의 일부를 PCB에 저장하지만, 문맥교환을 하는 2번의 경우 그 부담이 훨씬 큼.</li>
</ul>

<h2 id="스케줄링-큐">스케줄링, 큐</h2>

<h3 id="프로세스를-스케줄링하기-위한-큐">프로세스를 스케줄링하기 위한 큐</h3>

<ol>
  <li>
    <p>Job queue</p>

    <p>현재 시스템 내에 있는 모든 프로세스의 집합</p>
  </li>
  <li>
    <p>Ready Queue</p>

    <p>현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합</p>
  </li>
  <li>
    <p>Device Queue</p>

    <p>I/O device 의 처리를 기다리는 프로세스의 집합</p>
  </li>
</ol>

<p>프로세스의 흐름</p>

<ol>
  <li>Ready Queue 에서 대기</li>
  <li>(스케줄링에 의해) CPU 할당 받음</li>
  <li>대기하게 되는 경우
    <ol>
      <li>I/O 요청이 오면 I/O queue에서 대기</li>
      <li>자식 프로세스가 실행되는 경우</li>
      <li>Timer</li>
    </ol>
  </li>
  <li>다시 Ready Queue로 가서 대기</li>
</ol>

<h3 id="스케줄러scheduler">스케줄러(Scheduler)</h3>

<ol>
  <li>Long- term scheduler ( Job scheduler)
    <ul>
      <li>시작 프로세스 중 어떤 것을 ready queue로 보낼지</li>
      <li>프로세스에 memory를 주는 자원 할당 문제</li>
      <li>
        <p>degree of Multiprogramming을 제어</p>

        <p>: 메모리에 올라가는 프로그램의 수</p>

        <p>→ 너무 많아도, 적어도 안됌. 효율적이여야함.</p>
      </li>
    </ul>

    <p>✅ 우리가 쓰는 CPU(time sharing system)는 생성되면 무조건 Ready 로</p>
  </li>
  <li>Short-term scheduler ( CPU scheduler)
    <ul>
      <li>어떤 프로세스를 다음에 runnung 시킬지 결정.</li>
      <li>프로세스에 CPU를 주는 문제</li>
    </ul>
  </li>
  <li>Medium-term (Swapper)
    <ul>
      <li>일단 메모리에 다 올려 놓음</li>
      <li>여유공간이 필요하면 몇몇 프로세스를 통째로 메모리에서 디스크로 쫓아냄</li>
      <li>프로세스에게서 memory를 뺏는 문제</li>
      <li>degree of Multiprogramming 제어</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="thread">Thread</h2>

<h3 id="thread-란">Thread 란?</h3>

<p>Thread : 프로세스 내부의 CPU  수행 단위</p>

<ul>
  <li>
    <p>구성</p>

    <p>program counter / register set / stack space</p>
  </li>
  <li>
    <p>thread 가 동료 thread 와 공유하는 부분  ⇒ task</p>

    <p>code section   <br />
  data section   <br />
  OS resourses</p>
  </li>
  <li>
    <p>전통적인 개념의 heavyweight process는 하나의 thread를 가지고 있는 task로 볼 수 있다.</p>
  </li>
</ul>

<p><img src="/assets/images/posts/os/03-17-3-f.png" alt="프로세스6" /></p>

<p>메모리 공간은 하나만 띄워 놓고 현재 CPU가 프로그램의 어느 부분을 실행하고 있는 지에 대한 정보를 PCB에 저장하고. 여러개의  PCB를 둠.</p>

<p>T<strong>hread 특징</strong></p>

<ul>
  <li>한 thread 가 I/O 대기 중일 때 다른 thread가 다른 일을 처리함.</li>
  <li>높은 처리율(throughput)</li>
  <li>
    <p>병렬성</p>

    <p>⇒ CPU가 여러개 있는 컴퓨터에서 가능</p>
  </li>
  <li>
    <p>자원 절약</p>

    <p>⇒ 프로세스가 메모리에 올라와있으므로</p>
  </li>
  <li>프로세스는 하나라서 PCB는 하나만 존재</li>
  <li>CPU 관련 정보만 각 thread 별도로 저장
    <ul>
      <li>PC, register, stack</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/images/posts/os/03-17-3-g.png" alt="프로세스7" /></p>

<h3 id="thread의-장점">Thread의 장점</h3>

<ol>
  <li>
    <p>Responsiveness(응답성)</p>

    <p>사용자 입장에서 빠름</p>

    <p>ex) Web</p>

    <p>한 스레드가 네트워크 요청을 하면 html 문서는 빨리 응답이 오지만, img 같은 경우 늦게 응답이 오는 경우가 있다. 전송된 html 을 다른 스레드가 먼저 display 해주고, 다른 스레드는 계속 blocked 상태(응답 대기)</p>
  </li>
  <li>
    <p>자원 공유</p>

    <p>code, data 등 의 자원 공유, 메모리 절약 ?</p>
  </li>
  <li>
    <p>Economy</p>

    <p>프로세스 보다 스레드 생성하고 CPU switch가 일어나는 것이 오버헤드가 적다.</p>
  </li>
  <li>
    <p>병렬성</p>

    <p>CPU가 여러개인 경우, 병렬 수행</p>
  </li>
</ol>

<p>❓ Thread 의 병렬성 ????</p>

<p>CPU 가 여러개 일 때 각 스레드를 동시에 실행할 수 있어서 병렬 수행이 되는 것.  <br />
Thread 의 병렬성은 Thread 자체가 갖는 멀티 스레드를 말하는 것 같다. <a href="https://popcorntree.tistory.com/84?category=813524">참고 블로그</a></p>

<p><strong>Thread 종류</strong></p>

<ol>
  <li><strong>Kernal Thread</strong>
    <ul>
      <li>스레드가 여러개 있다는 사실을 운영체제가 알고 있음</li>
    </ul>
  </li>
  <li><strong>User Thread</strong>
    <ul>
      <li>스레드가 여러개 있다는 사실을 운영체제가 모름</li>
      <li>user 프로세스 스스로 여러개의 스레드를 관리함</li>
      <li>라이브러리로 지원</li>
    </ul>
  </li>
  <li><strong>real-time thread</strong></li>
</ol>

<p><br />
<br /></p>

<hr />

<p><br />
<br /></p>

<blockquote>
  <p>참고 <br />
    <a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323">KOCW 이화여자대학교 2014 반효경 교수님</a></p>
</blockquote>
:ET