I"4<h2 id="chapter4-process-management">Chapter4. Process Management</h2>

<h3 id="프로세스-생성">프로세스 생성</h3>

<ul>
  <li>부모 프로세스가 자식 프로세스 생성</li>
  <li>트리 구조 형성 ( 계층적 구조 )
    <ul>
      <li>부모는  1개, 자식은 여러개</li>
    </ul>
  </li>
  <li>프로세스는 자원을 필요로 함
    <ul>
      <li>운영체제로부터 받는다.</li>
      <li>부모와 공유한다.</li>
    </ul>
  </li>
  <li>자원 공유
    <ul>
      <li>부모 자식이 모든 자원을 공유</li>
      <li>일부 자원만 공유</li>
      <li>전혀 공유 하지 않음( 새 프로세스가 생성되면 이제 경쟁관계)</li>
    </ul>
  </li>
  <li>수행 모델
    <ul>
      <li>부모와 자식이 공존하며 수행되는 모델</li>
      <li>자식이 종료될 때까지 부모가 기다리는 모델</li>
    </ul>
  </li>
</ul>

<h3 id="프로세스-생성-방법">프로세스 생성 방법</h3>

<p>✅ 주소공간</p>

<ul>
  <li>자식은 부모의 공간을 복사함</li>
  <li>자식은 그 공간에 새로운 프로그램을 올림</li>
</ul>

<ol>
  <li>
    <p><strong>fork() ⇒ 복제생성</strong></p>

    <p>부모를 그대로 복사
 주소 공간 할당</p>
  </li>
  <li>
    <p><strong>exec() ⇒ 덮어씌우기</strong></p>

    <p>새로운 프로그램을 메모리에 올림</p>

    <p>✔️ 유닉스의 예</p>

    <p>fork() 시스템 콜이 새로운 프로세스를 생성한 후,      <br />
 fork() 다음에 이어지는 exec() 시스템 콜dmf 통해 새로운 프로그램을 메모리에 올림.</p>

    <p style="color:#ff5100">fork(), exec(), wait(), exit() 은 모두 시스템 콜</p>
  </li>
</ol>

<hr />

<h3 id="프로세스-종료">프로세스 종료</h3>

<ul>
  <li>프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려줌 <strong>⇒ exit</strong>
    <ul>
      <li>자식이 부모에게 output data를 보냄 <strong>⇒ via wait</strong></li>
      <li>프로세스의 각종 자원들이 운영체제에게 반납됨.</li>
    </ul>
  </li>
  <li>부모 프로세스가 자식의 수행을 종료시킴 <strong>⇒ abort</strong>
    <ul>
      <li>자식이 할당 자원의 한계치를 넘어섬</li>
      <li>자식에게 할당된 태스크가 더 이상 필요하지 않음</li>
      <li>부모가 종료하는 경우
        <ul>
          <li>운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되도록 두지 않는다.</li>
          <li>단계적 종료 (자식 종료 → 부모 종료)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>exit() ⇒ 자발적 종료  <br />
abort() ⇒ 비자발적 종료</p>

<p>❓abort 는 어떻게 불릴까 ?</p>

<p>✅ 부모와 자식 프로세스의 자원 공유</p>

<p>리눅스 등의 운영체제에서는 메모리 공간을 효율적으로 사용하기 위해  <br />
부모보다 자식의 공통된 자원을 복제하지 않고 공유한다.</p>

<p>만약, 부모와 자식의 내용이 달라지면 그때 복제한다. ⇒ <code class="language-plaintext highlighter-rouge">copy-in-write</code></p>

<h3 id="fork">fork()</h3>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	
<span class="cm">/*  parent  */</span>												
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
		<span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
	<span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"hello, I am child"</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">pid</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="cm">/* 부모는 여기 실행*/</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"hello, I am parent"</span><span class="p">);</span>	
</code></pre></div></div>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	
<span class="cm">/*  child*/</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
		<span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span> <span class="c1">// -&gt; 자식은 여기서부터 실행</span>
	<span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 자식은 여기 실행</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"hello, I am child"</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">pid</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"hello, I am parent"</span><span class="p">);</span><span class="mi">7</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>새로운 주소 공간을 만들고 부모 프로세스를 복제한다.</li>
</ul>

<p>❗ 부모의 context를 그대로 받는다.   <br />
<code class="language-plaintext highlighter-rouge">pid=fork()</code> 까지의 진행상황이 자식에게도 전달되어   <br />
자식 프로세스의 main 함수 시작 부분부터 실행되는 것이 아니라 fork()를 실행한 이후부터 실행한다.</p>

<p>✅ fork 의 리턴값</p>

<ul>
  <li>부모 process pid &gt; 0</li>
  <li>자식 process pid = 0</li>
</ul>

<h3 id="exec">exec()</h3>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">pid</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"hello, I am child! Now I'll run date"</span><span class="p">);</span>
		<span class="n">execlp</span><span class="p">(</span><span class="s">"/bin/date"</span><span class="p">,</span><span class="s">"/bin/date"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"hello, I am parent"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>기본의 프로그램은 지우고 새로운 프로그램이 메모리에 적재된다.</li>
  <li>자신의 메모리 공간을 새로운 프로그램으로 교체</li>
  <li>exec(), execpl() ← 이건 뭐지</li>
</ul>

<p>❗ 완전히 새로운 프로그램이 된다.  <br />
main 함수의 첫 부분부터 새로운 시작.</p>

<p>fork() 하고 exec() 하면 다시 자식으로 되돌아올 수 없다. 원래 있던 프로세스는 없어진다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"this is Child"</span><span class="p">);</span>                        <span class="c1">// 출력</span>
	<span class="n">execlp</span><span class="p">(</span><span class="s">"/bin/date"</span><span class="p">,</span><span class="s">"/bin/date"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">);</span>    <span class="c1">// 새로운 프로세스 메모리에 올라감</span>
<span class="c1">//execlp("프로세스 이름","프로세스 이름", (char *) 0);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"this is Parent"</span><span class="p">);</span>                       <span class="c1">// 덮어씌어지게 되므로 실행되지 않음</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="wait">wait()</h3>

<p><img src="/assets/images/posts/os/03-18-4-a.png" alt="프로세스관리1" /></p>

<ul>
  <li>프로세스 A 가 wait() 시스템 콜을 호출하면
    <ul>
      <li>커널은 child 가 종료될 때까지 프로세스 A를 sleep 시킨다 ⇒ block 상태</li>
      <li>Child process 가 종료되면 커널은 프로세스 A를 깨운다. ⇒ ready 상태</li>
    </ul>
  </li>
</ul>

<p>⇒ 부모는 자식 프로세스가 종료되길 기다리며 block 상태가 된다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span> <span class="nx">childPID</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
	<span class="p">&lt;</span> <span class="na">code</span> <span class="na">for</span> <span class="na">child</span> <span class="na">process</span><span class="p">&gt;</span>
}else<span class="si">{</span>
	<span class="nx">wait</span><span class="p">();</span>  <span class="c1">// 자식 프로세스가 종료되면 빠져나옴</span>
<span class="si">}</span>
</code></pre></div></div>

<ul>
  <li>프로그램 실행 모델 중 하나일 뿐, 다르게 동작하는 경우도 있음.</li>
</ul>

<h3 id="exit">exit()</h3>

<ul>
  <li>프로세스의 종료</li>
  <li>exit() 이후 전혀 실행되지 않음</li>
</ul>

<ol>
  <li>자발적 종료
    <ol>
      <li>마지막 statement 수행 후, exit() 시스템 콜을 통해.</li>
      <li>프로그램에 명시적으로 적어주지 않아도 main 함수가 리턴되는 위치에 컴파일러가 넣어줌.</li>
    </ol>
  </li>
  <li>비자발적 종료
    <ol>
      <li>부모 프로세스가 자식 프로세스를 강제 종료시킴
        <ul>
          <li>자식 프로세스가 한계치를 언어서는 자원 요청</li>
          <li>자식에게 할당된 태스크가 더 이상 필요하지 않음</li>
        </ul>
      </li>
      <li>키보드로 kill, break 하는 경우</li>
      <li>부모가 종료하는 경우
        <ul>
          <li>부모 프로세스가 종료하기 전에 자식들이 먼저 종료됨.</li>
        </ul>
      </li>
    </ol>

    <p>❗ 단계적 종료  <br />
 자식 프로세스가 종료된 후, 부모 프로세스가 종료되는 것이 국룰이므로  <br />
 부모 프로세스가 종료되면 자식 프로세스는 다 죽음.</p>
  </li>
</ol>

<h3 id="프로세스간-협력">프로세스간 협력</h3>

<ul>
  <li>독립적 프로세스
    <ul>
      <li>프로세스는 각자의 주소 공간을가지고 수행되므로 원칙적으로 하나의 프로세스는 다른프로세스의 수행에 영향을 미치지 못함.</li>
    </ul>
  </li>
  <li>협력 프로세스
    <ul>
      <li>프로세스 협력 매커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있음.</li>
    </ul>
  </li>
</ul>

<p><strong>협력 메커니즘( IPC )</strong></p>

<ol>
  <li>
    <p>메시지를 전달하는 방법</p>

    <p>✔️ <strong>message passing</strong></p>

    <ul>
      <li>커널을 통해 메시지 전달  <br />
  messagin system - 프로세스 사이에 공유 변수를 일체 사용하지 않고 통신하는 시스템</li>
    </ul>

    <ol>
      <li>Direct Communication
        <ul>
          <li>통신하려는 프로세스의 이름을 명시적으로 표시</li>
        </ul>
      </li>
      <li>Indirect Communication
        <ul>
          <li>mail box (또는 port)를 통해 메시지 간접 전달  <br />
 (해당 메시지를 받을 수 있는 다른 프로세스에게도 전달)</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p>주소 공간을 공유하는 방법</p>

    <ul>
      <li>shared memory : 서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 하는 shared memory 매커니즘</li>
    </ul>

    <p>✔️<strong>Interprocess Communication</strong></p>

    <p><img src="/assets/images/posts/os/03-18-4-b.png" alt="프로세스관리2" /></p>

    <ul>
      <li>메모리 주소 공간 공유. A가 쓰면 B가 바로 읽을 수 있음.</li>
      <li>shared memory 는 커널이 생성</li>
      <li>두 프로세스는 신뢰할 수 있는 관계여야한다.</li>
    </ul>
  </li>
</ol>

<p>✔️ thread 는 쓰레드간 협력, (프로세스 간 협력 x)</p>

<p>동일한 process를 구성하는 thread 간에는 주소 공간을 공유므로 협력 가능.</p>
:ET