I"@<h2 id="백준-14002-번-가장-긴-증가하는-부분-수열-4">백준 14002 번 가장 긴 증가하는 부분 수열 4</h2>

<p><a href="https://www.acmicpc.net/problem/14002">문제보기</a></p>

<h3 id="1-문제-풀이">1. 문제 풀이</h3>

<h4 id="lis최장-증가-수열-longest-increasing-subsequence-란">LIS(최장 증가 수열, Longest Increasing Subsequence) 란?</h4>
<p>원소가 n 개인 배열의 수열 중, 모든 원소가 이전 원소보다 크다는 조건을 만족하고, 그 길이가 최대인 부분 수열.</p>

<ul>
  <li>대표적인 DP 문제이다.</li>
  <li>가장 긴 증가하는 부분 수열의 길이 구하기
    <ul>
      <li><code class="language-plaintext highlighter-rouge">lis[i]</code> : 현재 i번재 원소까지 고려한 최장 증가 수열의 길이 저장</li>
      <li>i 이전까지의 원소를 확인하며 i까지 고려했을 때의 최장 길이를 저장한다. =&gt; j : 0 ~ (i-1)</li>
      <li>이 값을 다음 원소의 최장길이를 구하는 데에 사용하면 최종적으로 마지막 원소까지 구했을 때, lis[i]가 가장 큰 값이 최장 증가 수열의 길이이다.
        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">--)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">lis</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">lis</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">lis</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">lis</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
   <span class="o">}</span>
 <span class="o">}</span>
  <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">lis</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
<span class="o">}</span>
</code></pre></div>        </div>
      </li>
      <li>arr[i] &gt; arr[j] 이전 값보다 큰지 확인</li>
      <li><code class="language-plaintext highlighter-rouge">lis[i] &lt; lis[j] + 1</code> : 현재까지 저장된 lis 값보다 j 다음에 i가 오는 경우가 더 길이가 긴지 확인</li>
    </ul>
  </li>
</ul>

<p><a href="../assets/images/posts/2022-04-08-1.jpg">최장증가수열의 길이</a></p>

<ul>
  <li>최장 증가 수열 구하기
    <ul>
      <li>길이를 구하기 위해 작성한 DP 배열인 LIS 배열을 활용하자.</li>
      <li>앞에서 구한 길이의 max 값이 lis 어딘가에 저장되어 있을 것이고, 그 원소 값이 수열의 제일 마지막 원소일 것이다.</li>
      <li>max 값과 lis[i] 값이 같다면 다른 배열(<code class="language-plaintext highlighter-rouge">mark</code>)에marking 한다.</li>
      <li>max 값을 만들었던 max-1 값이 또 LIS 어딘가에 저장되어있을 것이다. 이 값을 찾기 위해 max 를 1 감소 시킨 후, 원소를 찾고 marking 한다.</li>
      <li>이 작업을 반복한다.</li>
      <li>mark 된 값을 순서대로 출력하여 최장 증가 부분 수열을 찾을 수 있다.
<a href="../assets/images/posts/2022-04-08-2.jpg">최장증가수열</a></li>
    </ul>
  </li>
</ul>

<h3 id="2-시행착오">2. 시행착오</h3>
<ul>
  <li>풀이가 생각 나지 않아 구글링했다.</li>
</ul>

<h3 id="3-코드">3. 코드</h3>

<script src="https://gist.github.com/yeonui-0626/ccc56420da2d79d390762194c9a12728.js"></script>

:ET